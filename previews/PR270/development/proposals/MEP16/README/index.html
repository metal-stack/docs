<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>metal-api as an Alternative Configuration Source for the firewall-controller · metal-stack</title><meta name="title" content="metal-api as an Alternative Configuration Source for the firewall-controller · metal-stack"/><meta property="og:title" content="metal-api as an Alternative Configuration Source for the firewall-controller · metal-stack"/><meta property="twitter:title" content="metal-api as an Alternative Configuration Source for the firewall-controller · metal-stack"/><meta name="description" content="Documentation for metal-stack."/><meta property="og:description" content="Documentation for metal-stack."/><meta property="twitter:description" content="Documentation for metal-stack."/><meta property="og:url" content="https://docs.metal-stack.io/development/proposals/MEP16/README/"/><meta property="twitter:url" content="https://docs.metal-stack.io/development/proposals/MEP16/README/"/><link rel="canonical" href="https://docs.metal-stack.io/development/proposals/MEP16/README/"/><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../search_index.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../../../assets/youtube.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.svg" alt="metal-stack logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">metal-stack</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Introduction</a></li><li><span class="tocitem">Overview</span><ul><li><a class="tocitem" href="../../../../overview/architecture/">Architecture</a></li><li><a class="tocitem" href="../../../../overview/networking/">Networking</a></li><li><a class="tocitem" href="../../../../overview/hardware/">Hardware Support</a></li><li><a class="tocitem" href="../../../../overview/os/">Operating Systems</a></li><li><a class="tocitem" href="../../../../overview/kubernetes/">Kubernetes Integration</a></li><li><a class="tocitem" href="../../../../overview/isolated-kubernetes/">Isolated Kubernetes</a></li><li><a class="tocitem" href="../../../../overview/gpu-support/">GPU Support</a></li><li><a class="tocitem" href="../../../../overview/storage/">Storage</a></li><li><a class="tocitem" href="../../../../overview/comparison/">Comparison</a></li></ul></li><li><a class="tocitem" href="../../../../quickstart/">Quickstart</a></li><li><span class="tocitem">Installation &amp; Administration</span><ul><li><a class="tocitem" href="../../../../installation/deployment/">Installation</a></li><li><a class="tocitem" href="../../../../installation/updates/">Releases and Updates</a></li><li><a class="tocitem" href="../../../../installation/monitoring/">Monitoring</a></li><li><a class="tocitem" href="../../../../installation/troubleshoot/">Troubleshoot</a></li></ul></li><li><span class="tocitem">User Guides</span><ul><li><a class="tocitem" href="../../../../external/mini-lab/README/">mini-lab</a></li><li><a class="tocitem" href="../../../../external/metalctl/README/">metalctl</a></li><li><a class="tocitem" href="../../../../external/csi-driver-lvm/README/">csi-driver-lvm</a></li><li><a class="tocitem" href="../../../../external/firewall-controller/README/">firewall-controller</a></li><li><a class="tocitem" href="../../../../external/tailscale/README/">tailscale</a></li></ul></li><li><a class="tocitem" href="../../../../apidocs/apidocs/">API Documentation</a></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../../../client_libraries/">Client Libraries</a></li><li><a class="tocitem" href="../../../planning_meetings/">Planning Meetings</a></li><li><a class="tocitem" href="../../">Enhancement Proposals</a></li><li><a class="tocitem" href="../../../contributing/">Contributing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>metal-api as an Alternative Configuration Source for the firewall-controller</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>metal-api as an Alternative Configuration Source for the firewall-controller</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/metal-stack/docs.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="github.com/metal-stack/docs.git" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="metal-api-as-an-Alternative-Configuration-Source-for-the-firewall-controller"><a class="docs-heading-anchor" href="#metal-api-as-an-Alternative-Configuration-Source-for-the-firewall-controller">metal-api as an Alternative Configuration Source for the firewall-controller</a><a id="metal-api-as-an-Alternative-Configuration-Source-for-the-firewall-controller-1"></a><a class="docs-heading-anchor-permalink" href="#metal-api-as-an-Alternative-Configuration-Source-for-the-firewall-controller" title="Permalink"></a></h1><p>In the current situation, a firewall as provisioned by metal-stack is a fully immutable entity. Any modifications on the firewall like changing the firewall ruleset must be done <em>somehow</em> by the user – the metal-api and hence metal-stack is not aware of its current state.</p><p>As part of our <a href="https://docs.metal-stack.io/stable/overview/kubernetes/#Gardener">integration with the Gardener project</a> we offer a solution called the <a href="https://github.com/metal-stack/firewall-controller">firewall-controller</a>, which is part of our <a href="https://github.com/metal-stack/metal-images/blob/6318a624861b18a559a9d37299bca5f760eef524/firewall/Dockerfile#L57-L58">firewall OS images</a> and addresses shortcomings of the firewall resource&#39;s immutability, which would otherwise be completely impractible to work with. The firewall-controller crashes infinitely if it is not properly configured through the userdata when using the firewall image of metal-stack.</p><p>The firewall-controller approach is tightly coupled to Gardener and it requires the administrator of the Gardener installation to pass a shoot and a seed kubeconfig through machine userdata when creating the firewall. How this userdata has to look like is not documented and is just part of another project called the <a href="https://github.com/metal-stack/firewall-controller-manager">firewall-controller-manager</a> (FCM), which task is to orchestrate rolling updates of firewall machines in a way that network traffic interruption is minimal when updating a firewall or applying a change to an immutable firewall configuration.</p><p>In general, a firewall entity in metal-stack has similarities to the machine entity but it has a fundamental difference: A user gains ownership over a machine after provisioning. They can access it through SSH, modify it at will and this is completely wanted. For firewalls, however, we do not want a user to access the provisioned firewall as the firewall is a privileged part of the infrastructure with access to the underlay network. The underlay can not be tampered with at any given point in time by a user as it can destroy the entire network traffic flow inside a metal-stack partition.</p><p>For this reason, we have a gap in the metal-stack project in terms of a missing solution for people who do not rely on the Gardener integration. We are basically leaving a user with the option to implement an orchestrated recreation of every possible change on the firewall to minimize traffic interruption for the machines sitting behind the firewall or re-implement the firewall-controller to how they want to use it for their use-case.</p><p>Also we do not have a clear distinction in the API between user and metal-stack operator for firewalls. If a user would allocate a firewall it is also possible for the user to inject his own SSH keys and access the firewall and tamper with the underlay network.</p><p>Parts of these problems are probably going to decrease with the work on <a href="../../MEP4/README/">MEP-4</a> where there will be dedicated APIs for users and administrators of metal-stack including fine-grained access tokens.</p><p>With this MEP we want to describe a way to improve this current situation and allow other users that do not rely on the Gardener integration – for whatever motivation they have – to adequately manage firewalls. For this, we propose an alternative configuration for the firewall-controller that is native to metal-stack and more independent of Gardener.</p><h2 id="Proposal"><a class="docs-heading-anchor" href="#Proposal">Proposal</a><a id="Proposal-1"></a><a class="docs-heading-anchor-permalink" href="#Proposal" title="Permalink"></a></h2><p>The central idea of this proposal is allowing the firewall-controller to use the metal-api as a configuration source. This should serve as an alternative strategy to the currently used FCM <code>Firewall</code> resource based approach in the Gardener use-case. Updates of the firewall rules should be possible through the metal-api.</p><p>The firewall-controller itself should now be able to decide which of the two main strategies should be used for the base configuration: a kubeconfig or the metal-api. This should be possible through a dedicated <em>firewall-controller-config</em>.</p><p>Using this config will now allow operators to fine-tune the data sources for all of its dynamic configuration tasks independently. For example the data source of the core firewall rules could be set either from the <code>Firewall</code> resource located in the Gardener <code>Seed</code> or the metal-apiserver node network entity, while the CWNPs should be fetched and applied from a given kubeconfig (the <code>Shoot</code> Kubeconfig in the Gardener case). This configuration file is intended to be injected during firewall creation through the userdata along with potential source connection credentials.</p><pre><code class="language-yaml hljs"># the name of the firewall, defaulted to the hostname
name: best-firewall-ever

sources:
  seed:
    kubeconfig: /path/to/seed.yaml # current gardener behavior
    namespace: shoot--proj--name
  shoot:
    kubeconfig: /path/to/shoot.yaml # current gardener behavior
    namespace: firewall
  metal:
    url: https://metal-api
    hmac: some-hmac
    type: Metal-View
    projectID: abc
  static:
    # static should mirror all information provided by the metal or seed/shoot sources
    firewall: # optional
      controllerURL: https://...
    cwnp:
      egress: []
      ingress: []

# all sub-controllers running on the firewall
# each can be configured independently
controllers:
  # this is the base controller
  firewall:
    source: seed # or: metal, static

    # these are optional: when not provided, they are disabled
    selfUpdate:
      enabled: true
    droptailer:
      enabled: true

  # these are optional: when not provided, they are disabled
  service:
    source: shoot # or: metal, static
  cwnp:
    source: shoot # or: metal, static
  monitor:
    source: shoot # currently only shoot is supported</code></pre><p>The existing behavior of the firewall-controller writing into <code>/etc/nftables/firewall-controller.v4</code> is not changed. The different controller configuration sources are internally treated in the same way as before. The <code>static</code> source can be used to prevent the firewall-controller from crashing and consistently providing a static ruleset. This might be interesting for metal-stack native use cases or environments where the metal-api cannot be accessed.</p><p>There must be one central nftables-rule-file-controller that is notified and triggered by all other controllers that contribute to the nftables configuration.</p><p>For example, in order to maintain the existing Gardener integration, the configuration file for the firewall-controller will look like this:</p><pre><code class="language-yaml hljs">name: shoot--abc--cluster-firewall-def
sources:
  seed:
    kubeconfig: /etc/firewall-controller/seed.yaml
    namespace: shoot--abc--cluster
  shoot:
    kubeconfig: /etc/firewall-controller/shoot.yaml
    namespace: firewall

controllers:
  firewall:
    source: seed
    
    selfUpdate:
      enabled: true
    droptailer:
      enabled: true

  service:
    source: shoot
  cwnp:
    source: shoot
  monitor:
    source: shoot</code></pre><p>Plain metal-stack users might use a configuration like this:</p><pre><code class="language-yaml hljs">name: best-firewall-ever

sources:
  metal:
    url: https://metal-api
    hmac: some-hmac
    type: Metal-View
    projectID: abc
    
controllers:
  firewall:
    source: metal
    selfUpdate:
      enabled: true
    droptailer:
      enabled: true

  cwnp:
    # firewall rules stored in firewall entity
    # potential improvement would be to attach the rules to the node network entity
    # be aware that the firewall and private networks are immutable
    # eventually we introduce a firewall ruleset entity
    source: metal</code></pre><p>In highly restricted environments that cannot access metal-api the static source could be used:</p><pre><code class="language-yaml hljs">name: most-restricted-firewall-ever

sources:
  static:
    firewall:
      controllerURL: https://...
    cwnp:
      egress: []
      ingress: []

controllers:
  firewall:
    source: static

  cwnp:
    source: static</code></pre><h3 id="Non-Goals"><a class="docs-heading-anchor" href="#Non-Goals">Non-Goals</a><a id="Non-Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Goals" title="Permalink"></a></h3><ul><li>Resolving the missing differentiation between users and administrators by letting users pass userdata and SSH keys to the firewall creation.<ul><li>This is even more related to <a href="../../MEP4/README/">MEP-4</a> than this MEP.</li></ul></li></ul><h3 id="Advantages"><a class="docs-heading-anchor" href="#Advantages">Advantages</a><a id="Advantages-1"></a><a class="docs-heading-anchor-permalink" href="#Advantages" title="Permalink"></a></h3><ul><li>Offers a native metal-stack solution that improves managing firewalls for users by adding dynamic reconfiguration through the metal-api<ul><li>e.g., in the mini-lab, users can now allocate a machine, then an IP address and announce this IP from the machine without having to re-create the firewall but by adding a firewall rule to the metal-api.</li></ul></li><li>Improve consistency throughout the API (firewall rules would reflect what is persisted in metal-api).</li><li>Other providers like Cluster API can leverage this approach, too.</li><li>It can contribute to solving the shoot migration issue (in Cluster API case the <code>clusterctl move</code> for firewall objects)<ul><li>For Gardener takes the seed out of the equation (of which the kubeconfig changes during shoot migration)</li><li>However: Things like egress rules, rate limiting, etc. are currently not part of the firewall or network entity in the metal-api. These would need to be added to one of them.</li></ul></li><li>Potentially resolve the issue that end-users can manipulate accounting data of the firewall through the <code>FirewallMonitor</code><ul><li>for this we would need to be able to report traffic data to metal-api</li></ul></li></ul><h3 id="Caveats"><a class="docs-heading-anchor" href="#Caveats">Caveats</a><a id="Caveats-1"></a><a class="docs-heading-anchor-permalink" href="#Caveats" title="Permalink"></a></h3><ul><li>Metal-View access is too broad for firewalls. Mitigated by <a href="../../MEP4/README/">MEP-4</a>.</li><li>Polling of the firewall-controller is bad for performance. Mitigated by <a href="../../MEP4/README/">MEP-4</a>.</li></ul><h3 id="Firewall-Controller-Manager"><a class="docs-heading-anchor" href="#Firewall-Controller-Manager">Firewall Controller Manager</a><a id="Firewall-Controller-Manager-1"></a><a class="docs-heading-anchor-permalink" href="#Firewall-Controller-Manager" title="Permalink"></a></h3><p>Currently the firewall-controller-manager expects the creators of a <code>FirewallDeployment</code> to use the defaulting webhook that is tailored to the Gardener integration in order to generate <code>Firewall.spec.userdata</code> or to override it manually. Currently <code>Firewall.spec.userdata</code> will never be set explicitly.</p><p>Instead we&#39;d like to propose <code>Firewall.spec.userdataContents</code> which will replace the old <code>userdata</code>-string by a typed data structure. The FCM will do the heavy lifting while the <code>FirewallDeployment</code> creator decides what should be configured.</p><pre><code class="language-yaml hljs">kind: FirewallDeployment
spec:
  template:
    spec:
      userdataContents:
      - path: /etc/firewall-controller/config.yaml
        content: |
          ---
          sources:
            static: {}
          controllers:
            firewall:
              source: static
      - path: /etc/firewall-controller/seed.yaml
        secretRef:
            name: seed-kubeconfig
            generateFirewallControllerKubeconfig: true
      - path: /etc/firewall-controller/shoot.yaml
        secretRef:
            name: shoot-kubeconfig</code></pre><h3 id="Gardener-Extension-Provider-Metal-Stack"><a class="docs-heading-anchor" href="#Gardener-Extension-Provider-Metal-Stack">Gardener Extension Provider Metal Stack</a><a id="Gardener-Extension-Provider-Metal-Stack-1"></a><a class="docs-heading-anchor-permalink" href="#Gardener-Extension-Provider-Metal-Stack" title="Permalink"></a></h3><p>The GEPM should be migrated to the new <code>Firewall.spec.userdataContents</code> field.</p><h3 id="Cluster-API-Provider-Metal-Stack"><a class="docs-heading-anchor" href="#Cluster-API-Provider-Metal-Stack">Cluster API Provider Metal Stack</a><a id="Cluster-API-Provider-Metal-Stack-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-API-Provider-Metal-Stack" title="Permalink"></a></h3><p><img src="../firewall-for-capms-overview.drawio.svg" alt="architectural overview"/></p><p>In Cluster API there are essentially two main clusters: the management cluster and the workload cluster while the CAPMS takes in the role of the GEPM. Typically a local bootstrap cluster is created in KinD which acts as the management cluster. It creates the workload cluster. Thereafter the ownership of the workload cluster is typically moved (using <code>clusterctl move</code>) to a different cluster which will then become the management cluster. The new management cluster might actually be the workload cluster itself.</p><p>In contrast to Gardener, Cluster API aims to be less opinionated and minimal. It is common practice to not install any non-required components or CRDs into the workload cluster by default. Therefore we cannot expect custom resources like <code>ClusterwideNetworkPolicy</code> or <code>FirewallMonitor</code> to be installed in the workload cluster but strongly recommend our users to do it. Therefore it&#39;s the responsibility of the operator to tell <a href="https://github.com/metal-stack/cluster-api-provider-metal-stack">cluster-api-provider-metal-stack</a> the kubeconfig for the cluster where these CRDs are installed and defined in.</p><p>A viable configuration for a <code>MetalStackCluster</code> that generates firewall rules based of <code>Service</code> type <code>LoadBalancer</code> and <code>ClusterwideNetworkPolicy</code> and expects them to be deployed in the workload cluster is shown below. The <code>FirewallMonitor</code> will be reported into the same cluster.</p><pre><code class="language-yaml hljs">kind: MetalStackCluster
metadata:
    name: ${CLUSTER_NAME}
spec:
    firewallTemplate:
        userdataContents:
          - path: /etc/firewall-controller/config.yaml
            secretName: ${CLUSTER_NAME}-firewall-controller-config

          - path: /etc/firewall-controller/workload.yaml
            # this is the kubeconfig generated by kubeadm
            secretName: ${CLUSTER_NAME}-kubeconfig
---
kind: Secret
metadata:
    name: ${CLUSTER_NAME}-firewall-controller-config
stringData:
    controllerConfig: |
        ---
        name: ${CLUSTER_NAME}-firewall

        sources:
          metal:
            url: ${METAL_API_URL}
            hmac: ${METAL_API_HMAC}
            type: ${METAL_API_HMAC_TYPE}
            projectID: ${METAL_API_PROJECT_ID}
          shoot:
            kubeconfig: /etc/firewall-controller/workload.yaml
            namespace: firewall
    
        controllers:
          firewall:
            source: metal
            selfUpdate:
              enabled: true
            droptailer:
              enabled: true

          service:
            source: shoot
          cwnp:
            source: shoot
          monitor:
            source: shoot</code></pre><p>Here the firewall-controller-config will be referenced by the <code>MetalStackCluster</code> as a <code>Secret</code>. Please note that the <code>Secret</code>s in <code>userdataContents</code> will not be fetched and will directly be passed to the <code>FirewallDeployment</code>. At first the reconciliation of it in the FCM will fail due to the missing Kubeconfig secret. After the <code>MetalStackCluster</code> has been marked as ready, CAPI will create this missing secret. Effectively the firewall and initial control plane node should be created at the same time.</p><p>This approach allows maximum flexibility as intended by Cluster API and is still able to provide robust rolling updates of firewalls.</p><p>An advanced use case of this flexibility would be a management cluster, that is in charge of multiple workload clusters. Where one workload cluster acts as a monitoring or tooling cluster, receives logs and the firewall monitor for the other workload clusters. The CWNPs could be defined here, all in a separate namespace.</p><h4 id="Cluster-API-Caveats"><a class="docs-heading-anchor" href="#Cluster-API-Caveats">Cluster API Caveats</a><a id="Cluster-API-Caveats-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-API-Caveats" title="Permalink"></a></h4><p>When the cluster is pivoted and reconciles its own firewall, a malfunctioning firewall prevents the cluster from self-healing and requires manual intervention by creating a new firewall. This is an inherent problem of the cluster-api approach. It can be circumvented by using an extra cluster to manage workload clusters.</p><p>In the current form of this approach firewalls and therefore the firewall egress and ingress rules are managed by the cluster operators that manage the cluster-api resources. Hence it will not be possible to gain a fine-grained control over every cluster operator&#39;s choices from a central ruleset at the level of metal-stack firewalls. In case this control surfaces as a requirement, it would need to be implemented in a firewall external to metal-stack.</p><h2 id="Roadmap"><a class="docs-heading-anchor" href="#Roadmap">Roadmap</a><a id="Roadmap-1"></a><a class="docs-heading-anchor-permalink" href="#Roadmap" title="Permalink"></a></h2><p>In general this proposal is not thought to be implemented in one batch. Instead an incremental approach is required.</p><ol><li><p>Enhance firewall-controller</p><ul><li>Reduce coupling between controllers</li><li>Introduce controller config</li><li>Abstract module to write into distinct nftable rules for every controller</li><li>Implement <code>sources.static</code>, but not <code>sources.metal</code></li><li>GEPM should set <code>FirewallDeployment.spec.template.spec.userdataContents</code></li></ul></li><li><p>Allow Cluster API to use the FCM with static ruleset</p><ul><li>Add <code>firewall.metal-stack.io/paused</code> annotation (managed by CAPMS during <code>clusterctl move</code>, theoretically useful for Gardener shoot migration as well to avoid shallow deletion).</li><li>Reconcile multiple <code>FirewallDeployment</code> resources across multiple namespaces. For Gardener the old behavior of reconciling only one namespace should persist.</li><li>Allow setting the <code>firewall.metal-stack.io/no-controller-connection</code> annotation through the <code>FirewallDeployment</code> (either through the template or inheritance).</li><li>Add <code>MetalStackCluster.spec.firewallTemplate</code>.</li><li>Make <code>MetalStackCluster.spec.nodeNetworkID</code> optional if <code>spec.firewallTemplate</code> given.</li></ul></li><li><p>Add <code>sources.metal</code> as configuration option.</p><ul><li>Allow updates of firewall rules in the metal-apiserver.</li><li>Depends on <a href="../../MEP4/README/">MEP-4</a> metal-apiserver progress</li></ul></li><li><p>Potentially migrate the GEPM to use <code>sources.metal</code></p></li></ol></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 10 June 2025 10:35">Tuesday 10 June 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
