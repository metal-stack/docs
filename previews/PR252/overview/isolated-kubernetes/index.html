<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Isolated Kubernetes · metal-stack</title><meta name="title" content="Isolated Kubernetes · metal-stack"/><meta property="og:title" content="Isolated Kubernetes · metal-stack"/><meta property="twitter:title" content="Isolated Kubernetes · metal-stack"/><meta name="description" content="Documentation for metal-stack."/><meta property="og:description" content="Documentation for metal-stack."/><meta property="twitter:description" content="Documentation for metal-stack."/><meta property="og:url" content="https://docs.metal-stack.io/overview/isolated-kubernetes/"/><meta property="twitter:url" content="https://docs.metal-stack.io/overview/isolated-kubernetes/"/><link rel="canonical" href="https://docs.metal-stack.io/overview/isolated-kubernetes/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/youtube.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="metal-stack logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">metal-stack</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Overview</span><ul><li><a class="tocitem" href="../architecture/">Architecture</a></li><li><a class="tocitem" href="../networking/">Networking</a></li><li><a class="tocitem" href="../hardware/">Hardware Support</a></li><li><a class="tocitem" href="../os/">Operating Systems</a></li><li><a class="tocitem" href="../kubernetes/">Kubernetes Integration</a></li><li class="is-active"><a class="tocitem" href>Isolated Kubernetes</a><ul class="internal"><li><a class="tocitem" href="#Design-Choices"><span>Design Choices</span></a></li><li><a class="tocitem" href="#Network-Design"><span>Network Design</span></a></li><li><a class="tocitem" href="#Flavors"><span>Flavors</span></a></li><li><a class="tocitem" href="#Application-Container-Images"><span>Application Container Images</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Related-Pull-Requests"><span>Related Pull Requests</span></a></li></ul></li><li><a class="tocitem" href="../gpu-support/">GPU Support</a></li><li><a class="tocitem" href="../storage/">Storage</a></li><li><a class="tocitem" href="../comparison/">Comparison</a></li></ul></li><li><a class="tocitem" href="../../quickstart/">Quickstart</a></li><li><span class="tocitem">Installation &amp; Administration</span><ul><li><a class="tocitem" href="../../installation/deployment/">Installation</a></li><li><a class="tocitem" href="../../installation/updates/">Releases and Updates</a></li><li><a class="tocitem" href="../../installation/monitoring/">Monitoring</a></li><li><a class="tocitem" href="../../installation/troubleshoot/">Troubleshoot</a></li></ul></li><li><span class="tocitem">User Guides</span><ul><li><a class="tocitem" href="../../external/mini-lab/README/">mini-lab</a></li><li><a class="tocitem" href="../../external/metalctl/README/">metalctl</a></li><li><a class="tocitem" href="../../external/csi-driver-lvm/README/">csi-driver-lvm</a></li><li><a class="tocitem" href="../../external/firewall-controller/README/">firewall-controller</a></li></ul></li><li><a class="tocitem" href="../../apidocs/apidocs/">API Documentation</a></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../../development/client_libraries/">Client Libraries</a></li><li><a class="tocitem" href="../../development/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../development/proposals/">Enhancement Proposals</a></li><li><a class="tocitem" href="../../development/contributing/">Contributing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Overview</a></li><li class="is-active"><a href>Isolated Kubernetes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Isolated Kubernetes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/metal-stack/docs.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="github.com/metal-stack/docs.git" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Isolated-Kubernetes-Clusters"><a class="docs-heading-anchor" href="#Isolated-Kubernetes-Clusters">Isolated Kubernetes Clusters</a><a id="Isolated-Kubernetes-Clusters-1"></a><a class="docs-heading-anchor-permalink" href="#Isolated-Kubernetes-Clusters" title="Permalink"></a></h1><ul><li><a href="#Isolated-Kubernetes-Clusters">Isolated Kubernetes Clusters</a></li><li class="no-marker"><ul><li><a href="#Design-Choices">Design Choices</a></li><li><a href="#Network-Design">Network Design</a></li><li class="no-marker"><ul><li><a href="#Strictly-Required-Container-Images">Strictly Required Container Images</a></li></ul></li><li><a href="#Flavors">Flavors</a></li><li class="no-marker"><ul><li><a href="#Cluster-Wide-Network-Policies-CWNP">Cluster Wide Network Policies CWNP</a></li><li><a href="#Internet-Access-Baseline">Internet Access Baseline</a></li><li><a href="#Internet-Access-Forbidden">Internet Access Forbidden</a></li><li class="no-marker"><ul><li><a href="#Egress-traffic">Egress traffic</a></li><li><a href="#Ingress-traffic">Ingress traffic</a></li></ul></li><li><a href="#Internet-Access-Restricted">Internet Access Restricted</a></li></ul></li><li><a href="#Application-Container-Images">Application Container Images</a></li><li><a href="#Implementation">Implementation</a></li><li class="no-marker"><ul><li><a href="#Gardener-Extension-Provider-Metal">Gardener Extension Provider Metal</a></li><li><a href="#OS-Metal-Extension">OS Metal Extension</a></li><li><a href="#Firewall-Controller-Manager-and-Firewall-Controller">Firewall Controller Manager and Firewall Controller</a></li><li><a href="#Cloud-Controller-Manager">Cloud Controller Manager</a></li><li><a href="#OCI-Mirror">OCI Mirror</a></li></ul></li><li><a href="#Related-Pull-Requests">Related Pull Requests</a></li></ul></li></ul><p>Some customers have the need to run their workloads in a very restricted environment. These restrictions are driven by regulatory requirements in some industries such as finance, healthcare, energy and more. Regulatory requirements often mandate that the workload must not be exposed to the public internet, nor is capable to reach the public internet in any case.</p><p>For this purpose we implemented a possibility to start Kubernetes clusters in such a manner. This is referred to as cluster isolation.</p><h2 id="Design-Choices"><a class="docs-heading-anchor" href="#Design-Choices">Design Choices</a><a id="Design-Choices-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Choices" title="Permalink"></a></h2><p>When talking about highly secure Kubernetes environments people often raise the term &quot;Air Gapped Cluster&quot;. This would mean that no physical connection exists between the Kubernetes control plane and the Kubernetes worker nodes with the outside world. This requirement exists in extreme environments such as ships, moon bases or nuclear plants. The effort to produce this in a completely automated manner is extremely challenging.</p><p>We decided to follow a different approach which is more practical, still very secure but much simpler to implement and operate. The solution we created is called &quot;Isolated Cluster&quot; which means that there are still physical connections between the Kubernetes cluster, but guarded to prohibit malicious traffic. It is also not possible to enable malicious traffic by accident, e.g. if a cluster user configures network policies or load balancers to untrusted environments.</p><h2 id="Network-Design"><a class="docs-heading-anchor" href="#Network-Design">Network Design</a><a id="Network-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Design" title="Permalink"></a></h2><p>In order to be able to restrict ingress and egress internet traffic, but still make it possible to create a working Kubernetes cluster we implemented the following network design.</p><ul><li>All strictly required container images are mirrored to a registry which is only accessible from the Kubernetes clusters.</li><li>DNS and NTP servers are produced alongside the registry.</li><li>The <code>containerd</code> configuration on every worker node is configured to pull all of the strictly required container images from this private registry mirror.</li><li>DNS and NTP configuration is also adopted to use the DNS and NTP servers on this private environment.</li><li>A list of networks which are allowed to reach is managed, this list reflects the networks of the cloud provider and is not modifiable by the cluster user. This list usually contains the internet prefixes of the provider and one or more RFC address ranges.</li></ul><p><img src="../isolated-kubernetes.drawio.svg" alt="Network Design"/></p><p>Users are advised to attach an additional network to the Kubernetes cluster in order to be able to pull container images for the application workloads from private registries.</p><h3 id="Strictly-Required-Container-Images"><a class="docs-heading-anchor" href="#Strictly-Required-Container-Images">Strictly Required Container Images</a><a id="Strictly-Required-Container-Images-1"></a><a class="docs-heading-anchor-permalink" href="#Strictly-Required-Container-Images" title="Permalink"></a></h3><p>In general the creation of a Kubernetes cluster requires the ability to pull container images for several applications which are necessary to make a machine a Kubernetes worker node. To mention the most important:</p><ul><li>Kubelet: the main controller on each worker node to manage the workload</li><li>CNI (Container Network Interface): controller and daemon set to setup and run the container networking</li><li>CSI (Container Storage Interface): controller and daemon set to setup and run the container storage</li><li>CoreDNS: DNS for containers</li><li>MetalLB: Service Type LoadBalancer Implementation</li><li>node-exporter and metrics-server: Monitoring for the worker node</li><li>Metal-Stack Addons: for firewall and auditing events</li></ul><h2 id="Flavors"><a class="docs-heading-anchor" href="#Flavors">Flavors</a><a id="Flavors-1"></a><a class="docs-heading-anchor-permalink" href="#Flavors" title="Permalink"></a></h2><p>With the introduction of Isolated Kubernetes Clusters, cluster users must decide upon cluster creation which type of isolation he needs for his workload. There are three different flavours available:</p><ul><li>Internet access <code>baseline</code>: This is the default cluster creation mode, which does not change any aspects of network and registry access.</li><li>Internet access <code>forbidden</code>: No internet access is possible, neither ingress nor egress.</li><li>Internet access <code>restricted</code>: No internet access is possible, neither ingress nor egress, but can be enabled by the cluster user.</li></ul><p>Please see the detailed description of these flavors below.</p><h3 id="Cluster-Wide-Network-Policies-CWNP"><a class="docs-heading-anchor" href="#Cluster-Wide-Network-Policies-CWNP">Cluster Wide Network Policies CWNP</a><a id="Cluster-Wide-Network-Policies-CWNP-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-Wide-Network-Policies-CWNP" title="Permalink"></a></h3><p>To restrict which egress traffic is allowed, Custom Resources <code>ClusterWideNetworkPolicy</code> are deployed and can be deployed by the cluster user. The set of deployed CWNPs differs between <code>baseline</code> and <code>forbidden</code>/<code>restricted</code>.</p><p><code>baseline</code> CWNPs:</p><table><tr><th style="text-align: left">Rule Name</th><th style="text-align: left">Destination</th><th style="text-align: left">Purpose</th></tr><tr><td style="text-align: left">allow-to-http</td><td style="text-align: left">0.0.0.0/0</td><td style="text-align: left">egress via http</td></tr><tr><td style="text-align: left">allow-to-https</td><td style="text-align: left">0.0.0.0/0</td><td style="text-align: left">egress via https</td></tr><tr><td style="text-align: left">allow-to-apiserver</td><td style="text-align: left">IP of the Kubernetes API Server on the control plane</td><td style="text-align: left">API Server communication of kubelet and other controllers</td></tr><tr><td style="text-align: left">allow-to-dns</td><td style="text-align: left">IP of the Google DNS Servers</td><td style="text-align: left">DNS resolution from the Kubernetes worker nodes and containers</td></tr><tr><td style="text-align: left">allow-to-ntp</td><td style="text-align: left">IP of the Cloudflare NTP Servers</td><td style="text-align: left">Time synchronization</td></tr><tr><td style="text-align: left">allow-to-storage</td><td style="text-align: left">network of the container storage</td><td style="text-align: left">persistent volumes with the cni driver</td></tr><tr><td style="text-align: left">allow-to-vpn</td><td style="text-align: left">IP of the vpn endpoint on the control plane</td><td style="text-align: left">allow communication from the api server to the kubelet for container logs and container exec</td></tr></table><p><code>forbidden</code> and <code>restricted</code> CWNPs:</p><table><tr><th style="text-align: left">Rule Name</th><th style="text-align: left">Destination</th><th style="text-align: left">Purpose</th></tr><tr><td style="text-align: left">allow-to-apiserver</td><td style="text-align: left">IP of the Kubernetes API Server on the control plane</td><td style="text-align: left">API Server communication of kubelet and other controllers</td></tr><tr><td style="text-align: left">allow-to-dns</td><td style="text-align: left">IP of the private DNS Server</td><td style="text-align: left">DNS resolution from the Kubernetes worker nodes and containers</td></tr><tr><td style="text-align: left">allow-to-ntp</td><td style="text-align: left">IP of the private NTP Server</td><td style="text-align: left">Time synchronization</td></tr><tr><td style="text-align: left">allow-to-registry</td><td style="text-align: left">IP of the private Registry Mirror</td><td style="text-align: left">Pulling strictly required container images</td></tr><tr><td style="text-align: left">allow-to-storage</td><td style="text-align: left">network of the container storage</td><td style="text-align: left">persistent volumes with the cni driver</td></tr><tr><td style="text-align: left">allow-to-vpn</td><td style="text-align: left">IP of the vpn endpoint on the control plane</td><td style="text-align: left">allow communication from the api server to the kubelet for container logs and container exec</td></tr></table><p>All of these CWNPs are managed by the <a href="https://github.com/metal-stack/gardener-extension-provider-metal">gardener-extension-provider-metal</a>, every manual modification will be reverted immediately.</p><h3 id="Internet-Access-Baseline"><a class="docs-heading-anchor" href="#Internet-Access-Baseline">Internet Access Baseline</a><a id="Internet-Access-Baseline-1"></a><a class="docs-heading-anchor-permalink" href="#Internet-Access-Baseline" title="Permalink"></a></h3><p>This is the default configuration of a Kubernetes cluster, egress traffic is controlled by multiple CWNPs (<code>ClusterWideNetworkPolicy</code>), ingress traffic is possible by deploying a Service Type LoadBalancer. The cluster user can add additional CWNPs without any restrictions and is responsible for them.</p><p>Container images can be pulled from any reachable container registry. The <code>containerd</code> is not reconfigured to point to our private registry mirror.</p><p>DNS and NTP are configured to internet DNS resolvers and NTP servers.</p><h3 id="Internet-Access-Forbidden"><a class="docs-heading-anchor" href="#Internet-Access-Forbidden">Internet Access Forbidden</a><a id="Internet-Access-Forbidden-1"></a><a class="docs-heading-anchor-permalink" href="#Internet-Access-Forbidden" title="Permalink"></a></h3><p>This configuration can only be achieved by creating a new Kubernetes cluster, it is not possible to modify a existing cluster (with internet access <code>baseline</code> or <code>restricted</code>) to this configuration. It is also required to specify the most recent version of Kubernetes, older versions of Kubernetes are not supported.</p><p>Every network access modification triggered by a cluster user, either by adding or modifying CWNPs or adding a Service Type LoadBalancer, is validated against the list of allowed networks.</p><p><code>containerd</code> is configured so that all required images are pulled from the private registry mirror. This registry contains only the strictly required images, therefore no additional (workload) images can be pulled from public registries.</p><h4 id="Egress-traffic"><a class="docs-heading-anchor" href="#Egress-traffic">Egress traffic</a><a id="Egress-traffic-1"></a><a class="docs-heading-anchor-permalink" href="#Egress-traffic" title="Permalink"></a></h4><p>Egress traffic is only allowed to the private registry mirror and the DNS and NTP servers. Additional CWNPs can be added to reach destinations in the internal networks if specified. If a CWNP was created which points to a destination outside of the allowed networks, the CWNP will still be present but stays in the status <code>ignored</code>.</p><pre><code class="language-bash hljs">&gt; kubectl get clusterwidenetworkpolicies.metal-stack.io
NAME                 STATUS     MESSAGE
allow-to-apiserver   deployed
allow-to-dns         deployed
allow-to-ntp         deployed
allow-to-registry    deployed
allow-to-storage     deployed
allow-to-vpn         deployed
allow-to-google      ignored    ingress/egress does not match allowed networks</code></pre><p>Also an event is created which describes why the CWNP was ignored:</p><pre><code class="language-bash hljs">&gt; kubectl get events
5s         Warning   ForbiddenCIDR         clusterwidenetworkpolicy/allow-to-google    address:&quot;8.8.8.8/32&quot; is outside of the allowed network range:&quot;10.0.0.0/8,100.64.0.0/10,212.34.83.0/27&quot;, ignoring</code></pre><h4 id="Ingress-traffic"><a class="docs-heading-anchor" href="#Ingress-traffic">Ingress traffic</a><a id="Ingress-traffic-1"></a><a class="docs-heading-anchor-permalink" href="#Ingress-traffic" title="Permalink"></a></h4><p>Ingress traffic is only allowed from the internal networks if specified. To specify the address where the Service Type LoadBalancer is listening to, the cluster user must use one of his statically acquired ip addresses. Of course, this ip address is only considered if it is contained in the list of allowed networks. Then this ip address must be configured in the service:</p><pre><code class="language-yaml hljs">apiVersion: v1
kind: Service
spec:
  type: LoadBalancer
  loadBalancerIP: 10.1.1.1 # ip from the internal network</code></pre><p>By default, no ip address will be automatically selected for such clusters and the ip of the service will stay in pending mode until the ip was specified as shown above.</p><pre><code class="language-bash hljs">&gt; kubectl get svc
NAME              TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE
example-service   LoadBalancer   10.244.75.171   &lt;pending&gt;     443:32179/TCP   4s

&gt; kubectl get events
8s          Warning   AllocationFailed         service/example-service   Failed to allocate IP for &quot;default/example-service&quot;: no available IPs
3s          Warning   SyncLoadBalancerFailed   service/example-service   Error syncing load balancer: failed to ensure load balancer: no default network for ip acquisition specified, acquire an ip for your cluster&#39;s project and specify it directly in &quot;spec.loadBalancerIP&quot;</code></pre><h3 id="Internet-Access-Restricted"><a class="docs-heading-anchor" href="#Internet-Access-Restricted">Internet Access Restricted</a><a id="Internet-Access-Restricted-1"></a><a class="docs-heading-anchor-permalink" href="#Internet-Access-Restricted" title="Permalink"></a></h3><p>This configuration can only be achieved by creating a new Kubernetes cluster, it is not possible to modify a existing cluster (with internet access <code>baseline</code> or <code>forbidden</code>) to this configuration. It is also required to specify the most recent version of Kubernetes, older versions of Kubernetes are not supported.</p><p>The same default CWNPs are deployed and the container images are pulled from the private registry. Also DNS and NTP are configured to use the private DNS and NTP servers. The only difference to the <code>forbidden</code> mode is that CWNPs and Service Type LoadBalancers can be created without the restriction that only allowed networks are allowed.</p><p>Pulling container images is theoretically possible if a cluster user creates a CWNP which allows network access to an external registry. But most container registries serve the container images from large CDN networks, which have a lot of ip addresses. Simply adding the ip address of docker.io is therefore not sufficient.</p><h2 id="Application-Container-Images"><a class="docs-heading-anchor" href="#Application-Container-Images">Application Container Images</a><a id="Application-Container-Images-1"></a><a class="docs-heading-anchor-permalink" href="#Application-Container-Images" title="Permalink"></a></h2><p>In order to deploy application containers into a cluster with Internet Access <code>forbidden</code> a private registry must be provided. This private registry must be located in the list of allowed networks. The DNS name of the registry must resolve in the public DNS servers. The registry must be secured with a TLS certificate that is also valid with the CA certificates from the worker node, e.g. vanilla debian ca-certificates.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>To achieve this functionality modifications have been implemented in various components in metal-stack, this includes:</p><h3 id="Gardener-Extension-Provider-Metal"><a class="docs-heading-anchor" href="#Gardener-Extension-Provider-Metal">Gardener Extension Provider Metal</a><a id="Gardener-Extension-Provider-Metal-1"></a><a class="docs-heading-anchor-permalink" href="#Gardener-Extension-Provider-Metal" title="Permalink"></a></h3><p>The ControlPlane API is adopted to enable a user to configure a shoot with the internet access type <code>forbidden</code> or <code>restricted</code>. The CloudProfile can now be extended to carry the list of allowed networks, the dns and ntp servers, the registry with the mirrored registries.</p><p>ControlPlane:</p><pre><code class="language-go hljs">// ControlPlaneConfig contains configuration settings for the control plane.
type ControlPlaneConfig struct {
    metav1.TypeMeta

    // NetworkAccessType defines how the cluster can reach external networks.
    // +optional
    NetworkAccessType *NetworkAccessType
}
type (
    // NetworkAccessType defines how a cluster is capable of accessing external networks
    NetworkAccessType string
)

const (
    // NetworkAccessBaseline allows the cluster to access external networks in a baseline manner
    NetworkAccessBaseline = NetworkAccessType(&quot;baseline&quot;)
    // NetworkAccessRestricted access to external networks is by default restricted to registries, dns and ntp to partition only destinations.
    // Therefore registries, dns and ntp destinations must be specified in the cloud-profile accordingly.
    // If this is not the case, restricting the access must not be possible.
    // Image overrides for all images which are required to create such a shoot, must be specified. No other images are provided in the given registry.
    // customers can define own rules to access external networks as in the baseline.
    // Service type LoadBalancers are also not restricted.
    NetworkAccessRestricted = NetworkAccessType(&quot;restricted&quot;)
    // NetworkAccessForbidden in this configuration a customer can no longer create rules to access external networks.
    // which are outside of a given list of allowed networks. This is enforced by the firewall.
    // Service type LoadBalancers are also not possible to open a service ip which is not in the list of allowed networks.
    // This is also enforced by the firewall.
    NetworkAccessForbidden = NetworkAccessType(&quot;forbidden&quot;)
)</code></pre><p>A sample Shoot Spec:</p><pre><code class="language-yaml hljs">---
apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: isolated
  namespace: sample
spec:
  provider:
    type: metal
      controlPlaneConfig:
        networkAccessType: forbidden
...</code></pre><p>CloudProfile:</p><pre><code class="language-go hljs">type NetworkIsolation struct {
    // AllowedNetworks is a list of networks which are allowed to connect in restricted or forbidden NetworkIsolated clusters.
    AllowedNetworks AllowedNetworks
    // DNSServers
    DNSServers []string
    // NTPServers
    NTPServers []string
    // The registry which serves the images required to create a shoot.
    RegistryMirrors []RegistryMirror
}

// AllowedNetworks is a list of networks which are allowed to connect in restricted or forbidden NetworkIsolated clusters.
type AllowedNetworks struct {
    // Ingress defines a list of networks which are allowed for incoming traffic like service type LoadBalancer
    // to allow all you must specify 0.0.0.0/0 or ::/0
    Ingress []string
    // Egress defines a list of networks which are allowed for outgoing traffic
    // to allow all you must specify 0.0.0.0/0 or ::/0
    Egress []string
}

type RegistryMirror struct {
    // Name describes this server
    Name string
    // Endpoint is typically the url of the registry in the form https://hostname
    Endpoint string
    // IP is the ipv4 or ipv6 address of this server
    IP string
    // Port at which port the service is reachable
    Port int32
    // This Registry Mirror mirrors the following registries
    MirrorOf []string   
}</code></pre><p>A sample configuration in the CloudProfile would look like:</p><pre><code class="language-yaml hljs">  network-isolation:
    allowedNetworks:
      egress:
      - 1.2.3.0/24 # Internet CIDR of the Provider
      - 100.64.0.0/10
      - 10.0.0.0/8
      ingress:
      - 100.64.0.0/10
    dnsServers:
      - &quot;1.2.3.1&quot;
      - &quot;1.2.3.2&quot;
      - &quot;1.2.3.3&quot;
    ntpServers:
      - &quot;1.2.3.1&quot;
      - &quot;1.2.3.2&quot;
      - &quot;1.2.3.3&quot;
    registryMirrors:
      - name: test registry
        endpoint: https://some.private.registry
        ip: &quot;1.2.3.4&quot;
        port: 443
        mirrorOf:
            - &quot;docker.io&quot;
            - &quot;quay.io&quot;
            - &quot;eu.gcr.io&quot;
            - &quot;ghcr.io&quot;
            - &quot;registry.k8s.io&quot;</code></pre><h3 id="OS-Metal-Extension"><a class="docs-heading-anchor" href="#OS-Metal-Extension">OS Metal Extension</a><a id="OS-Metal-Extension-1"></a><a class="docs-heading-anchor-permalink" href="#OS-Metal-Extension" title="Permalink"></a></h3><p>Based on the configuration of a cluster the configuration of the containerd must be changed to pull images from the private registry mirror. If a cluster is either configured with <code>restricted</code> or <code>forbidden</code>, the configuration of containerd will be created as such:</p><p>config.toml</p><pre><code class="language-toml hljs"># Generated by os-extension-metal
version = 2
imports = [&quot;/etc/containerd/conf.d/*.toml&quot;]

disabled_plugins = []
[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]
  config_path = &quot;/etc/containerd/certs.d&quot;</code></pre><p>And for every registry mirror an additional <code>certs.d/$HOST/hosts.yaml</code> will be created. This is in line with <a href="https://gardener.cloud/docs/gardener/advanced/containerd-registry-configuration/">Gardener&#39;s containerd Registry Configuration</a>.</p><pre><code class="language-toml hljs"># certs.d/docker.io/hosts.yaml

server = &quot;https://docker.io&quot;
[host.&quot;https://some.private.registry&quot;]
  capabilities = [&quot;pull&quot;, &quot;resolve&quot;]</code></pre><p>DNS and NTP must also be adopted according to the configuration in the CloudProfile.</p><h3 id="Firewall-Controller-Manager-and-Firewall-Controller"><a class="docs-heading-anchor" href="#Firewall-Controller-Manager-and-Firewall-Controller">Firewall Controller Manager and Firewall Controller</a><a id="Firewall-Controller-Manager-and-Firewall-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Firewall-Controller-Manager-and-Firewall-Controller" title="Permalink"></a></h3><p>The Firewall Controller Manager has extended the FirewallSpec to configure the Firewall Controller which must enforce the restrictions regarding allowed networks.</p><pre><code class="language-go hljs">// FirewallSpec defines parameters for the firewall creation along with configuration for the firewall-controller.
type FirewallSpec struct {
    // AllowedNetworks defines which networks are allowed to connect to, and allow incoming traffic from.
    // Is enforced with NetworkAccessForbidden.
    // The node network is always allowed.
    AllowedNetworks AllowedNetworks `json:&quot;allowedNetworks,omitempty&quot;`
}

// AllowedNetworks is a list of networks which are allowed to connect when NetworkAccessType is NetworkAccessForbidden.
type AllowedNetworks struct {
    // Ingress defines a list of cidrs which are allowed for incoming traffic like service type LoadBalancer
    Ingress []string `json:&quot;ingress,omitempty&quot;`
    // Egress defines a list of cidrs which are allowed for outgoing traffic
    Egress []string `json:&quot;egress,omitempty&quot;`
}</code></pre><p>Also the ClusterwideNetworkPolicy in the Firewall Controller was changed to show the deployment status of a CWNP.</p><pre><code class="language-go hljs">
type ClusterwideNetworkPolicy struct {
    metav1.TypeMeta   `json:&quot;,inline&quot;`
    metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`   

    Spec   PolicySpec   `json:&quot;spec,omitempty&quot;`
    Status PolicyStatus `json:&quot;status,omitempty&quot;`
}

// PolicyDeploymentState describes the state of a CWNP deployment
type PolicyDeploymentState string

const (
    // PolicyDeploymentStateDeployed the CWNP was deployed to a native nftable rule
    PolicyDeploymentStateDeployed = PolicyDeploymentState(&quot;deployed&quot;)
    // PolicyDeploymentStateIgnored the CWNP was not deployed to a native nftable rule because it is outside of the allowed networks
    PolicyDeploymentStateIgnored  = PolicyDeploymentState(&quot;ignored&quot;)
)

// PolicyStatus defines the observed state for CWNP resource
type PolicyStatus struct {
    // FQDNState stores mapping from FQDN rules to nftables sets used for a firewall rule.
    // Key is either MatchName or MatchPattern
    // +optional
    FQDNState FQDNState `json:&quot;fqdn_state,omitempty&quot;`   
    // State of the CWNP, can be either deployed or ignored
    State PolicyDeploymentState `json:&quot;state&quot;`  
    // Message describe why the state changed
    Message string `json:&quot;message,omitempty&quot;`
}</code></pre><h3 id="Cloud-Controller-Manager"><a class="docs-heading-anchor" href="#Cloud-Controller-Manager">Cloud Controller Manager</a><a id="Cloud-Controller-Manager-1"></a><a class="docs-heading-anchor-permalink" href="#Cloud-Controller-Manager" title="Permalink"></a></h3><p>This component was adopted to allow to be started without a default network specified. This was actually always the internet network and if no ip address was specified in the Service Type LoadBalancer, one ip was allocated from this default network. For isolated clusters this is not provided and a cluster user must always specify this ip to get a working load balancer.</p><h3 id="OCI-Mirror"><a class="docs-heading-anchor" href="#OCI-Mirror">OCI Mirror</a><a id="OCI-Mirror-1"></a><a class="docs-heading-anchor-permalink" href="#OCI-Mirror" title="Permalink"></a></h3><p>The <a href="https://github.com/metal-stack/oci-mirror">OCI Mirror</a> is a new application which acts as a scheduled job that pulls a given list of container images and pushes them to a private registry (which will then serve as the private registry mirror). The detailed description can be read on the project website.</p><h2 id="Related-Pull-Requests"><a class="docs-heading-anchor" href="#Related-Pull-Requests">Related Pull Requests</a><a id="Related-Pull-Requests-1"></a><a class="docs-heading-anchor-permalink" href="#Related-Pull-Requests" title="Permalink"></a></h2><ul><li><a href="https://github.com/metal-stack/gardener-extension-provider-metal/pull/361">Gardener Extension Provider</a></li><li><a href="https://github.com/metal-stack/firewall-controller-manager/pull/48">Firewall Controller Manager</a></li><li><a href="https://github.com/metal-stack/firewall-controller/pull/172">Firewall Controller</a></li><li><a href="https://github.com/metal-stack/os-metal-extension/pull/38">OS Metal Extension</a></li><li><a href="https://github.com/metal-stack/metal-ccm/pull/87">Metal Cloud Controller Manager</a></li><li><a href="https://github.com/metal-stack/metal-networker/pull/101">Metal Networker</a></li><li><a href="https://github.com/metal-stack/metal-images/pull/214">Metal Images</a></li><li><a href="https://github.com/metal-stack/oci-mirror">OCI Mirror</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../kubernetes/">« Kubernetes Integration</a><a class="docs-footer-nextpage" href="../gpu-support/">GPU Support »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 5 March 2025 08:03">Wednesday 5 March 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
