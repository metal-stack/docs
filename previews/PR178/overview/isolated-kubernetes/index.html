<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Isolated Kubernetes · metal-stack</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.metal-stack.io/overview/isolated-kubernetes/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/youtube.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="metal-stack logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">metal-stack</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Overview</span><ul><li><a class="tocitem" href="../architecture/">Architecture</a></li><li><a class="tocitem" href="../networking/">Networking</a></li><li><a class="tocitem" href="../hardware/">Hardware Support</a></li><li><a class="tocitem" href="../os/">Operating Systems</a></li><li><a class="tocitem" href="../kubernetes/">Kubernetes Integration</a></li><li class="is-active"><a class="tocitem" href>Isolated Kubernetes</a><ul class="internal"><li><a class="tocitem" href="#Network-Design"><span>Network Design</span></a></li><li><a class="tocitem" href="#Flavors"><span>Flavors</span></a></li><li><a class="tocitem" href="#Application-Container-Images"><span>Application Container Images</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li></ul></li><li><a class="tocitem" href="../storage/">Storage</a></li><li><a class="tocitem" href="../comparison/">Comparison</a></li></ul></li><li><a class="tocitem" href="../../quickstart/">Quickstart</a></li><li><span class="tocitem">Installation &amp; Administration</span><ul><li><a class="tocitem" href="../../installation/deployment/">Installation</a></li><li><a class="tocitem" href="../../installation/monitoring/">Monitoring</a></li><li><a class="tocitem" href="../../installation/troubleshoot/">Troubleshoot</a></li></ul></li><li><span class="tocitem">User Guides</span><ul><li><a class="tocitem" href="../../external/mini-lab/README/">mini-lab</a></li><li><a class="tocitem" href="../../external/metalctl/README/">metalctl</a></li><li><a class="tocitem" href="../../external/csi-driver-lvm/README/">csi-driver-lvm</a></li><li><a class="tocitem" href="../../external/firewall-controller/README/">firewall-controller</a></li></ul></li><li><a class="tocitem" href="../../apidocs/apidocs/">API Documentation</a></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../../development/client_libraries/">Client Libraries</a></li><li><a class="tocitem" href="../../development/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../development/proposals/">Enhancement Proposals</a></li><li><a class="tocitem" href="../../development/contributing/">Contributing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Overview</a></li><li class="is-active"><a href>Isolated Kubernetes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Isolated Kubernetes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="github.com/metal-stack/docs.git" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Isolated-Kubernetes-Clusters"><a class="docs-heading-anchor" href="#Isolated-Kubernetes-Clusters">Isolated Kubernetes Clusters</a><a id="Isolated-Kubernetes-Clusters-1"></a><a class="docs-heading-anchor-permalink" href="#Isolated-Kubernetes-Clusters" title="Permalink"></a></h1><ul><li><a href="#Isolated-Kubernetes-Clusters">Isolated Kubernetes Clusters</a></li><li class="no-marker"><ul><li><a href="#Network-Design">Network Design</a></li><li class="no-marker"><ul><li><a href="#Strictly-required-Container-Images">Strictly required Container Images</a></li></ul></li><li><a href="#Flavors">Flavors</a></li><li class="no-marker"><ul><li><a href="#Internet-Access-Baseline">Internet Access Baseline</a></li><li><a href="#Internet-Access-Forbidden">Internet Access Forbidden</a></li><li class="no-marker"><ul><li><a href="#Egress-traffic">Egress traffic</a></li><li><a href="#Ingress-traffic">Ingress traffic</a></li></ul></li><li><a href="#Internet-Access-Restricted">Internet Access Restricted</a></li></ul></li><li><a href="#Application-Container-Images">Application Container Images</a></li><li><a href="#Implementation">Implementation</a></li><li class="no-marker"><ul><li><a href="#Gardener-Extension-Provider-Metal">Gardener Extension Provider Metal</a></li><li><a href="#OS-Metal-Extension">OS Metal Extension</a></li><li><a href="#Firewall-Controller-Manager-and-Firewall-Controller">Firewall Controller Manager and Firewall Controller</a></li><li><a href="#Cloud-Controller-Manager">Cloud Controller Manager</a></li><li><a href="#OCI-Mirror">OCI Mirror</a></li></ul></li></ul></li></ul><p>Some Customers have the need to run their workloads in a very restricted environment. These restrictions are driven by regulatory requirements in some industries such as finance, healthcare, energy and more. The Regulatory requirements often define that the workload must not be exposed to the public internet, nor is capable to reach the public internet in any case.</p><p>For this purpose we implemented a possibility to start kubernetes clusters in such a manner. This is called isolated cluster.</p><h2 id="Network-Design"><a class="docs-heading-anchor" href="#Network-Design">Network Design</a><a id="Network-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Design" title="Permalink"></a></h2><p>In order to be able to restrict ingress and egress internet traffic, but still make it possible to create a working kubernetes cluster we implemented the following network design.</p><ul><li>All strictly required container images are mirrored to a registry which is only accessible from the kubernetes clusters.</li><li>DNS and NTP Servers are produced alongside the registry.</li><li>The containerd configuration on every worker node is configured to pull all of the strictly required container images from this private registry mirror,</li><li>DNS and NTP configuration is also adopted to use the DNS and NTP Servers on this private environment.</li><li>A list of networks which are allowed to reach is managed, this list reflects the network of the cloud provider and is not modifiable by the cluster user.</li></ul><p><img src="../isolated-kubernetes.drawio.svg" alt="Network Design"/></p><p>It is required to attach a additional network to the kubernetes cluster in order to be able to pull container images for the application workloads from private registries.</p><h3 id="Strictly-required-Container-Images"><a class="docs-heading-anchor" href="#Strictly-required-Container-Images">Strictly required Container Images</a><a id="Strictly-required-Container-Images-1"></a><a class="docs-heading-anchor-permalink" href="#Strictly-required-Container-Images" title="Permalink"></a></h3><p>In general the creation of a kubernetes cluster requires the ability to pull container images for several applications which are necessary to make a machine a functional worker node. To mention a few:</p><ul><li>Kubelet: the main controller on each worker node to manage the workload</li><li>CNI (Container Network Interface): controller and daemon set to setup and run the container networking</li><li>CSI (Container Storage Interface): controller and daemon set to setup and run the container storage</li><li>CoreDNS: DNS for containers</li><li>MetalLB: Service Type Loadbalancer Implementation</li><li>Node-Exporter and Metrics-Exporter: Monitoring for the worker node</li><li>Metal-Stack Addons: for firewall and auditing events</li></ul><p>Because we configured containerd as such, that all images which are required are pulled from the private registry, it is not possible anymore to pull container images which are located at docker.io or quay.io for example, because all requests to these registries will be redirected to the registry mirror which only contains the images we mirror.</p><p>For application workloads please see below how these images must be provided.</p><h2 id="Flavors"><a class="docs-heading-anchor" href="#Flavors">Flavors</a><a id="Flavors-1"></a><a class="docs-heading-anchor-permalink" href="#Flavors" title="Permalink"></a></h2><p>The way kubernetes clusters can be created changed in this perspective. There are three different flavors of kubernetes cluster: Internet Access Baseline, Restricted and Forbidden. This results in the following restrictions:</p><h3 id="Internet-Access-Baseline"><a class="docs-heading-anchor" href="#Internet-Access-Baseline">Internet Access Baseline</a><a id="Internet-Access-Baseline-1"></a><a class="docs-heading-anchor-permalink" href="#Internet-Access-Baseline" title="Permalink"></a></h3><p>This is the default configuration of a kubernetes cluster, egress traffic is controlled by multiple CWNP&#39;s (Cluster Wide Network Policy), ingress traffic is possible by deploying a Service Type Loadbalancer. The cluster user can add additional CWNP&#39;s without any restrictions and is responsible for them.</p><p>Container images can be pulled from any reachable container registry.</p><p>DNS and NTP are configured to internet DNS Resolvers and NTP Servers</p><p>The list of CWNP&#39;s which are deployed by default are:</p><pre><code class="language-bash hljs">&gt; kubectl get clusterwidenetworkpolicies.metal-stack.io
NAME                 STATUS     MESSAGE
allow-to-http        deployed
allow-to-https       deployed
allow-to-apiserver   deployed
allow-to-dns         deployed
allow-to-ntp         deployed
allow-to-registry    deployed
allow-to-storage     deployed
allow-to-vpn         deployed</code></pre><p>The purposes of this CWNPs are:</p><p>| Rule Name          | |Destination                                          | Purpose                                                                                      | |––––––––––|-|––––––––––––––––––––––––––-|–––––––––––––––––––––––––––––––––––––––––––––––| | allow-to-apiserver |  |IP of the Kubernetes API Server on the control plane | API Server communication of kubelet and other controllers                                    | | allow-to-dns       |  |IP of the private DNS Server                         | DNS resolution from the Kubernetes worker nodes and containers                               | | allow-to-ntp       |  |IP of the private NTP Server                         | Time synchronization                                                                         | | allow-to-registry  |  |IP of the private Registry Mirror                    | Pulling strictly required container images                                                   | | allow-to-storage   |  |network of the container storage                     | persistent volumes with the cni driver                                                       | | allow-to-vpn       |  |IP of the vpn endpoint on the control plane          | allow communication from the api server to the kubelet for container logs and container exec |</p><p>All of these CWNPs are managed by the gardener-extension-provider-metal, every manual modification will be reverted immediately.</p><h3 id="Internet-Access-Forbidden"><a class="docs-heading-anchor" href="#Internet-Access-Forbidden">Internet Access Forbidden</a><a id="Internet-Access-Forbidden-1"></a><a class="docs-heading-anchor-permalink" href="#Internet-Access-Forbidden" title="Permalink"></a></h3><p>This configuration can only be achieved by creating a new kubernetes cluster, it is not possible to modify a existing cluster (with internet access baseline or restricted) to this configuration. It is also required to specify the most recent version of kubernetes, older versions of kubernetes are not supported.</p><p>Every network access modifications triggered by a cluster user, either by adding/modifying CWNPs or adding a Service Type Loadbalancer, is validated against a list of allowed Networks. If the cluster was created with a additional internal network, this network is part of the allowed networks list.</p><p>With internet access forbidden the following restrictions apply:</p><h4 id="Egress-traffic"><a class="docs-heading-anchor" href="#Egress-traffic">Egress traffic</a><a id="Egress-traffic-1"></a><a class="docs-heading-anchor-permalink" href="#Egress-traffic" title="Permalink"></a></h4><p>Is only allowed to the registry and the DNS and NTP servers by default. Additional CWNPs can be added to reach destinations in the internal networks if specified. If a CWNP was created which points to a destination outside of the allowed networks, the CWNP will still be present but will stay in the Status <code>ignored</code>.</p><pre><code class="language-bash hljs">&gt; kubectl get clusterwidenetworkpolicies.metal-stack.io
NAME                 STATUS     MESSAGE
allow-to-apiserver   deployed
allow-to-dns         deployed
allow-to-ntp         deployed
allow-to-registry    deployed
allow-to-storage     deployed
allow-to-vpn         deployed
allow-to-google      ignored    ingress/egress does not match allowed networks</code></pre><p>Also a event is created which describes why the CWNP was ignored:</p><pre><code class="language-bash hljs">&gt; kubectl get events
5s         Warning   ForbiddenCIDR         clusterwidenetworkpolicy/allow-to-google    address:&quot;8.8.8.8/32&quot; is outside of the allowed network range:&quot;10.0.0.0/8,100.64.0.0/10,212.34.83.0/27&quot;, ignoring</code></pre><h4 id="Ingress-traffic"><a class="docs-heading-anchor" href="#Ingress-traffic">Ingress traffic</a><a id="Ingress-traffic-1"></a><a class="docs-heading-anchor-permalink" href="#Ingress-traffic" title="Permalink"></a></h4><p>Is only allowed from the internal networks if specified. To specify the address where the service type loadbalancer is listening to, the cluster user must first select a IP Address from the internal network the cluster was connected to additionally. Then this IP Address must be configured in the service:</p><pre><code class="language-yaml hljs">apiVersion: v1
kind: Service
spec:
  type: LoadBalancer
  loadBalancerIP: 10.1.1.1</code></pre><p>By default, no IP Address will be automatically selected for such clusters and the ip of the service will stay in pending mode until the ip was specified as shown above.</p><h3 id="Internet-Access-Restricted"><a class="docs-heading-anchor" href="#Internet-Access-Restricted">Internet Access Restricted</a><a id="Internet-Access-Restricted-1"></a><a class="docs-heading-anchor-permalink" href="#Internet-Access-Restricted" title="Permalink"></a></h3><p>This configuration can only be achieved by creating a new kubernetes cluster, it is not possible to modify a existing cluster (with internet access baseline or forbidden) to this configuration. It is also required to specify the most recent version of kubernetes, older versions of kubernetes are not supported.</p><p>The same default CWNPs are deployed and the container images are pulled from the private registry. Also DNS and NTP are configured to use the private DNS and NTP servers. The only difference to the forbidden mode is that CWNPs and Service Type Loadbalancers can be created without the restriction that only allowed networks are allowed.</p><p>Pulling container images is theoretically possible, if a cluster creates a CWNP which allows network access to the registry host of the container image. Most container registries serve the container images from large CDN Networks which have a lot of IP Addresses. Simply adding the IP Address of docker.io is therefore not sufficient.</p><h2 id="Application-Container-Images"><a class="docs-heading-anchor" href="#Application-Container-Images">Application Container Images</a><a id="Application-Container-Images-1"></a><a class="docs-heading-anchor-permalink" href="#Application-Container-Images" title="Permalink"></a></h2><p>In order to deploy application containers into a cluster with Internet Access Forbidden a private registry must be provided located in the list of allowed networks. The DNS name of the registry must resolve in the public DNS Servers. The registry must be secured with a TLS certificate which is also valid with the ca-certificates from the worker node, e.g. vanilla debian ca-certificates.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>To achieve this functionality modifications has been implemented in various components in metal-stack, this includes:</p><h3 id="Gardener-Extension-Provider-Metal"><a class="docs-heading-anchor" href="#Gardener-Extension-Provider-Metal">Gardener Extension Provider Metal</a><a id="Gardener-Extension-Provider-Metal-1"></a><a class="docs-heading-anchor-permalink" href="#Gardener-Extension-Provider-Metal" title="Permalink"></a></h3><p>The ControlPlane API is adopted to enable a user to configure a shoot with the internet access type forbidden or restricted. The CloudProfile can now be extended to carry the list of allowed networks, the dns and ntp servers, the registry with the mirrored registries.</p><p>ControlPlane:</p><pre><code class="language-go hljs">// ControlPlaneConfig contains configuration settings for the control plane.
type ControlPlaneConfig struct {
    metav1.TypeMeta

    // NetworkAccessType defines how the cluster can reach external networks.
    // +optional
    NetworkAccessType *NetworkAccessType
}
type (
    // NetworkAccessType defines how a cluster is capable of accessing external networks
    NetworkAccessType string
)

const (
    // NetworkAccessBaseline allows the cluster to access external networks in a baseline manner
    NetworkAccessBaseline = NetworkAccessType(&quot;baseline&quot;)
    // NetworkAccessRestricted access to external networks is by default restricted to registries, dns and ntp to partition only destinations.
    // Therefore registries, dns and ntp destinations must be specified in the cloud-profile accordingly-
    // If this is not the case, restricting the access must not be possible.
    // Image overrides for all images which are required to create such a shoot, must be specified. No other images are provided in the given registry.
    // customers can define own rules to access external networks as in the baseline.
    // Service type loadbalancers are also not restricted.
    NetworkAccessRestricted = NetworkAccessType(&quot;restricted&quot;)
    // NetworkAccessForbidden in this configuration a customer can no longer create rules to access external networks.
    // which are outside of a given list of allowed networks. This is enforced by the firewall.
    // Service type loadbalancers are also not possible to open a service ip which is not in the list of allowed networks.
    // This is also enforced by the firewall.
    NetworkAccessForbidden = NetworkAccessType(&quot;forbidden&quot;)
)</code></pre><p>CloudProfile:</p><pre><code class="language-go hljs">type NetworkIsolation struct {
    // AllowedNetworks is a list of networks which are allowed to connect in restricted or forbidden NetworkIsolated clusters.
    // if empty all destinations are allowed.
    AllowedNetworks AllowedNetworks
    // DNSServers
    DNSServers []string
    // NTPServers
    NTPServers []string
    // The registry which serves the images required to create a shoot.
    RegistryMirrors []RegistryMirror
}

// AllowedNetworks is a list of networks which are allowed to connect in restricted or forbidden NetworkIsolated clusters.
type AllowedNetworks struct {
    // Ingress defines a list of networks which are allowed for incoming traffic like service type loadbalancer
    // to allow all you must specify 0.0.0.0/0 or ::/0
    Ingress []string
    // Egress defines a list of networks which are allowed for outgoing traffic
    // to allow all you must specify 0.0.0.0/0 or ::/0
    Egress []string
}

type RegistryMirror struct {
    // Name describes this server
    Name string
    // Endpoint is typically the url of the registry in the form https://hostname
    Endpoint string
    // IP is the ipv4 or ipv6 address of this server
    IP string
    // Port at which port the service is reachable
    Port int32
    // This Registry Mirror mirrors the following registries
    MirrorOf []string   
}</code></pre><h3 id="OS-Metal-Extension"><a class="docs-heading-anchor" href="#OS-Metal-Extension">OS Metal Extension</a><a id="OS-Metal-Extension-1"></a><a class="docs-heading-anchor-permalink" href="#OS-Metal-Extension" title="Permalink"></a></h3><p>Based on the configuration of a cluster the configuration of the containerd must be changed to pull images from the private registry mirror. If a cluster is either configured with restricted or forbidden, the configuration of containerd will be created as such:</p><p>config.toml</p><pre><code class="language-toml hljs">imports = [&quot;/etc/containerd/conf.d/*.toml&quot;]
version = 2

[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]
  [plugins.&quot;io.containerd.grpc.v1.cri&quot;.reg
    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]
      endpoint = [&quot;https://some.private.registry&quot;]
    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;quay.io&quot;]
      endpoint = [&quot;https://some.private.registry&quot;]
    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.lightbitslabs.com&quot;]
      endpoint = [&quot;https://some.private.registry&quot;]
    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;eu.gcr.io&quot;]
      endpoint = [&quot;https://some.private.registry&quot;]
    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;ghcr.io&quot;]
      endpoint = [&quot;https://some.private.registry&quot;]
    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;registry.k8s.io&quot;]
      endpoint = [&quot;https://some.private.registry&quot;]
    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;r.metal-stack.io&quot;]
      endpoint = [&quot;https://some.private.registry&quot;]</code></pre><p>DNS and NTP must also be adopted according the configuration in the CloudProfile.</p><h3 id="Firewall-Controller-Manager-and-Firewall-Controller"><a class="docs-heading-anchor" href="#Firewall-Controller-Manager-and-Firewall-Controller">Firewall Controller Manager and Firewall Controller</a><a id="Firewall-Controller-Manager-and-Firewall-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Firewall-Controller-Manager-and-Firewall-Controller" title="Permalink"></a></h3><p>The  Firewall Controller Manager changed the FirewallSpec to configure the Firewall Controller which must enforce the restrictions regarding allowed networks.</p><pre><code class="language-go hljs">// FirewallSpec defines parameters for the firewall creation along with configuration for the firewall-controller.
type FirewallSpec struct {
    // AllowedNetworks defines which networks are allowed to connect to, and allow incoming traffic from.
    // Is only enforced with NetworkAccessForbidden.
    // The node network is always allowed.
    AllowedNetworks AllowedNetworks `json:&quot;allowedNetworks,omitempty&quot;`
    // NetworkAccessType defines how the cluster can reach external networks.
    NetworkAccessType NetworkAccessType `json:&quot;networkAccessType,omitempty&quot;`
}

// AllowedNetworks is a list of networks which are allowed to connect when NetworkAccessType is NetworkAccessForbidden.
type AllowedNetworks struct {
    // Ingress defines a list of cidrs which are allowed for incoming traffic like service type loadbalancer
    Ingress []string `json:&quot;ingress,omitempty&quot;`
    // Egress defines a list of cidrs which are allowed for outgoing traffic
    Egress []string `json:&quot;egress,omitempty&quot;`
}

type (
    // NetworkAccessType defines how a cluster is capable of accessing external networks
    NetworkAccessType string
)

const (
    // NetworkAccessBaseline allows the cluster to access external networks in a baseline manner
    NetworkAccessBaseline = NetworkAccessType(&quot;baseline&quot;)
    // NetworkAccessRestricted access to external networks is by default restricted to registries, dns and ntp to partition only destinations.
    // Therefore registries, dns and ntp destinations must be specified in the cloud-profile accordingly-
    // If this is not the case, restricting the access must not be possible.
    // Image overrides for all images which are required to create such a shoot, must be specified. No other images are provided in the given registry.
    // customers can define own rules to access external networks as in the baseline.
    // Service type loadbalancers are also not restricted.
    NetworkAccessRestricted = NetworkAccessType(&quot;restricted&quot;)
    // NetworkAccessForbidden in this configuration a customer can no longer create rules to access external networks.
    // which are outside of a given list of allowed networks. This is enforced by the firewall.
    // Service type loadbalancers are also not possible to open a service ip which is not in the list of allowed networks.
    // This is also enforced by the firewall.
    NetworkAccessForbidden = NetworkAccessType(&quot;forbidden&quot;)
)</code></pre><p>Also the ClusterwideNetworkPolicy in the Firewall Controller was changed to show the deployment status of a CWNP.</p><pre><code class="language-go hljs">
type ClusterwideNetworkPolicy struct {
    metav1.TypeMeta   `json:&quot;,inline&quot;`
    metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`   

    Spec   PolicySpec   `json:&quot;spec,omitempty&quot;`
    Status PolicyStatus `json:&quot;status,omitempty&quot;`
}

// PolicyDeploymentState describes the state of a CWNP deployment
type PolicyDeploymentState string

const (
    // PolicyDeploymentStateDeployed the CWNP was deployed to a native nftable rule
    PolicyDeploymentStateDeployed = PolicyDeploymentState(&quot;deployed&quot;)
    // PolicyDeploymentStateIgnored the CWNP was not deployed to a native nftable rule because it is outside of allowed networks
    PolicyDeploymentStateIgnored  = PolicyDeploymentState(&quot;ignored&quot;)
)

// PolicyStatus defines the observed state for CWNP resource
type PolicyStatus struct {
    // FQDNState stores mapping from FQDN rules to nftables sets used for a firewall rule.
    // Key is either MatchName or MatchPattern
    // +optional
    FQDNState FQDNState `json:&quot;fqdn_state,omitempty&quot;`   
    // State of the CWNP, can be either deployed or ignored
    State PolicyDeploymentState `json:&quot;state&quot;`  
    // Message describe why the state changed
    Message string `json:&quot;message,omitempty&quot;`
}</code></pre><h3 id="Cloud-Controller-Manager"><a class="docs-heading-anchor" href="#Cloud-Controller-Manager">Cloud Controller Manager</a><a id="Cloud-Controller-Manager-1"></a><a class="docs-heading-anchor-permalink" href="#Cloud-Controller-Manager" title="Permalink"></a></h3><p>This component was adopted to allow to be started without a default network specified. This was actually always the internet network and if no ip address was specified in the Service Type Loadbalancer, one ip was allocated from this default network. For restricted and isolated clusters this is not provided and a cluster user must always specify this ip to get a working loadbalancer.</p><h3 id="OCI-Mirror"><a class="docs-heading-anchor" href="#OCI-Mirror">OCI Mirror</a><a id="OCI-Mirror-1"></a><a class="docs-heading-anchor-permalink" href="#OCI-Mirror" title="Permalink"></a></h3><p>The <a href="https://github.com/metal-stack/oci-mirror">OCI Mirror</a> is a new application which acts as a scheduled job which pulls a given list of container images and pushes them to a private registry. The detailed description can be read on the project website.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../kubernetes/">« Kubernetes Integration</a><a class="docs-footer-nextpage" href="../storage/">Storage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 29 January 2024 13:37">Monday 29 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
